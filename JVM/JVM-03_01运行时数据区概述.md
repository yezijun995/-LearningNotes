# JVM运行时数据区概述

**JVM总体架构图**

![](http://picturebed.yifelix.cn/blogimgs/jvm02/01.png)

本文是针对Run Time Data Areas(运行时数据区)进行简单概述

## 一、概述

Java虚拟机在执行Java程序的过程中会把它管理的内存分为若干个不同的数据区域。这些区域有着各自的用途，有些是创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》中规定，jvm所管理的内存大致包括以下几个运行时数据区域，如图所示：

![](http://picturebed.yifelix.cn/blogimgs/jvm04/01.png)

此图来源阿里，阿里将元空间与CodeCache独立出来，而有些是将CodeCache合并在一起，本质没有差异。此图是基于。

运行时数据区分别有五大块：PC Register(程序计数器)，Native Method Stacks(本地方法栈)，JVM Stacks（虚拟机栈），Heap（JAVA 堆），Method area（方法区）。



**1. PC Register(程序计数器)**

占据一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。

　　由于jvm的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此未来线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们成这类内存区域为“线程私有”的内存。

　　如果线程正在执行的是一个Java方法，这个计数器记录的则是正在执行的虚拟机字节码指令的地址；

　　如果正在执行的是Native方法，这个计数器则为空（undefined）。

**2. Native Method Stacks(本地方法栈)**

本地方法栈是用于管理本地方法的调用。本地方法栈与虚拟机栈所发挥的作用非常相似，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机中使用到的native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接把本地方法栈和虚拟机栈合二为一，与虚拟机栈一样也会抛出Stack OverflowError异常和OutOfMemoryError异常。

**3. JVM Stacks（虚拟机栈）**

Java虚拟机栈，早起也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。

**4.Heap（JAVA 堆）**

一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。对于大多数应用来说，堆空间是jvm内存中最大的一块。Java堆是被**所有线程共享**，虚拟机启动时创建，此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，在JVM启动的时候其空间大小也就确定（注：堆内存的大小是可以调节的）。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。从内存回收角度看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间，To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。（如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。）

**5.Method area（方法区）**

JDK8方法区的具体实现是**元空间**，而JDK8之前是**永久代**，与对一样也是被**所有线程共享**，主要用于存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 二、Runtime类

在每一个java**进程**之中都会存在有一个Runtime类的对象。由于此类的对象是由Java进程自己维护，所以在整个Runtime类设计的过程之中，只为用户提供了唯一的一个实例化对象。所以这个类所使用的就是单例设计模式，构造方法被私有化了。所以其类的内部一定会提供有一个static方法取得本类的实例化对象。

**常用方法：**

````java
//获取当前Runtime类实例化对象
Runtime run = Runtime.getRuntime();
//获取所有可用内存大小
System.out.println("JVM所有可用内存：" + run.totalMemory());

//获取最大可用内存大小
System.out.println("JVM最大可用内存：" + run.maxMemory());

//获取所有空闲内存大小
System.out.println("JVM空闲可用内存：" + run.freeMemory());

//执行垃圾回收
run.gc();

//JVM处理器数量
System.out.println("JVM处理器数量：" + run.availableProcessors());
````

