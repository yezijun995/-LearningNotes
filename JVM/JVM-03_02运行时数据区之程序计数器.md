# 运行时数据区之程序计数器

## 介绍

程序计数器是一个记录着当前线程所执行的字节码的行号指示器。JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。

一个线程对应一个 JVM Stack。JVM Stack 中包含一组 Stack Frame。当 JVM 调用一个 Java 方法时，它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入 JVM 栈中。

在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。

## 作用

PC寄存器是用来存储指向**下一条指令的地址，也即将将要执行的指令代码**。由执行引擎读取下一条指令。

1.它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域

2.在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致

3.任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）,**因为程序计数器不负责本地方法栈。**

4.它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成

5.字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令

6.它是唯一一个在java虚拟机规范中**没有规定任何OOM（Out Of Memery）**情况的区域,而且没有垃圾回收

![](http://picturebed.yifelix.cn/blogimgs/jvm05/01.png)

代码演示：

````java
int i = 10;
int j = 20;
int k = i + j;
````

将此代码进行编译成字节码文件，在对字节码文件进行javap反编译

````txt
0: bipush        10//定义了一个数字10，入栈
2: istore_1        //把它放到操作数栈索引为1的位置
3: bipush        20
5: istore_2
6: iload_1        //把代码取出来
7: iload_2
8: iadd           //相加
9: istore_3       //将结果入栈，保存到索引为3的位置
10: return        //返回 main函数结束
````

![](http://picturebed.yifelix.cn/blogimgs/jvm05/02.png)

## CPU时间片

CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。

在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。

但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。