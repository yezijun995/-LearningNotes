# JVM 类加载器之双亲委派机制

在看之前需先了解类加载器以及类加载过程，可以参考我的博客：[JVM类加载子系统](http://www.yifelix.cn/blog/99)

## 工作原理

![](http://picturebed.yifelix.cn/blogimgs/jvm03/01.png)

如上图箭头所示，除了启动类加载器，每个类加载器都有一个父加载器。构成了一个类加载器结构系统。这个系统就是用来完成双亲委派机制的。

**当一个类加载器收到了类加载请求，它并不会自己先去加载，而是将这个请求委托给父类的加载器去执行，如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。**这就是双亲委派机制。

比如当我们自己手写一个com.test.Test类，因为是我们自定义的类，它会先去进行系统类加载器进行加载，而系统类加载器会向上委托到扩展类加载器，然后扩展类加载器再把加载任务委托给引导类加载器，引导类加载器没有父加载器。于是它自己尝试加载，但是引导类加载器只能加载核心类库(上篇文章中讲到过引导类与扩展类加载器只会加载指定的类加载器),引导类加载器加载失败交由子加载器自己处理，但是扩展类加载器也无法加载，继续交由子加载器处理，又回到了系统类加载器，系统类加载器进行加载动作，加载成功。

## 双亲委派机制作用

双亲委派是Java语言的一大创新。表明看起来，由于双亲委派机制的存在，类加载器的数量增多了不少，增加了程序的复杂性。但是它可以避免类的重复加载，保护程序安全，防止核心API被随意修改，保证核心API包的访问权限。保证每次加载都委托父类的过程让类对象在内存中的数量保持为一个，让同类名的类无法被替换。

假如当我们自定义一个java.lang.String类，想篡改String类时，但是在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以并不会再去加载，从一定程度上防止了危险代码的植入。

